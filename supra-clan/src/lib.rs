#![cfg_attr(not(feature = "std"), no_std)]

/// Edit this file to define custom logic or remove it if it is not needed.
/// Learn more about FRAME and the core library of Substrate FRAME pallets:
/// <https://substrate.dev/docs/en/knowledgebase/runtime/frame>
use frame_support::{decl_error, decl_event, decl_module, decl_storage, dispatch::DispatchResult, ensure, sp_tracing::info, traits::{EnsureOrigin, Get}};
use scale_info::prelude::format;
use sp_core::OpaquePeerId as PeerId;

use sp_std::collections::btree_set::BTreeSet;

// #[cfg(test)]
// mod tests;

sp_api::decl_runtime_apis! {
	/// 'Clan' API trait used to couple nodes to form Clan.
	pub trait ClanApi{
		fn register_peer(peer: sp_core::OpaquePeerId) -> DispatchResult;

		fn threshold_met(threshold: u32) -> bool;
	}
}

pub trait Config: frame_system::Config {
    /// The overarching dispatch call type.
    type Call: From<Call<Self>>;
    /// Because this pallet emits events, it depends on the runtime's definition of an event.
    type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;
    /// Stoarage set numbers for nodes permitted into clan
    type MaxClanNodes: Get<u32>;
    /// The origin which can add a well known node.
    type CheckOrigin: EnsureOrigin<Self::Origin>;
}

decl_storage! {
    trait Store for Module<T: Config> as SupraClan {
        /// Set of nodes comprising of nodes in a clan
        pub Clan get(fn clan_nodes): BTreeSet<PeerId>;
    }
    add_extra_genesis {
        config(nodes): PeerId;
        build(|config: &GenesisConfig| {
            <Module<T>>::form_clan(config.nodes.clone()).unwrap();
        })
    }
}

decl_event! {
    /// Events generated by the module.
    pub enum Event<T>
    where
        AccountId = <T as frame_system::Config>::AccountId,
    {
        /// Clan is initiated
        FormClan,
        /// Event submitted when a node joins the clan.
        JoinClan(Option<AccountId>, PeerId),
        /// Event sunmitted when a node leaves the clan
        LeaveClan(u32),
    }
}

decl_error! {
    pub enum Error for Module<T: Config> {
        /// Clan nodes not active
        ClanNotResponsive,
        /// Clan length is exceeded
        TooManyNodes,
        /// Nodes already in Clan
        AlreadyJoined,
        NotInClan,
    }
}

decl_module! {
    pub struct Module<T: Config> for enum Call
        where 	origin: T::Origin,
    {
        fn deposit_event() = default;

        #[weight = 1000]
        pub fn clan_form(origin, node: PeerId) -> DispatchResult {
            T::CheckOrigin::ensure_origin(origin)?;

            Self::form_clan(node).unwrap();

            Self::deposit_event(RawEvent::FormClan);

            Ok(())
        }

        #[weight = 1000]
        pub fn node_join_clan(origin, node: PeerId) -> DispatchResult {
            T::CheckOrigin::ensure_origin(origin)?;

            let mut nodes = Clan::get();
            ensure!(nodes.len() < T::MaxClanNodes::get() as usize, Error::<T>::TooManyNodes);
            ensure!(!nodes.contains(&node), Error::<T>::AlreadyJoined);

            nodes.insert(node.clone());

            let node_peer = format!("{:#?}", node.clone());

            info!("{:?} joins clan", node_peer);

            Clan::put(&nodes);

            Self::deposit_event(RawEvent::JoinClan(None, node));

            Ok(())
        }

        #[weight = 1000]
        pub fn node_leave_clan(origin, node: PeerId) -> DispatchResult {
            T::CheckOrigin::ensure_origin(origin)?;

            let mut nodes = Clan::get();
            ensure!(nodes.len() < T::MaxClanNodes::get() as usize, Error::<T>::TooManyNodes);
            ensure!(nodes.contains(&node), Error::<T>::NotInClan);

            nodes.remove(&node);

            let node_peer = format!("{:#?}", node.clone());

            info!("{:?} joins clan", node_peer);

            Clan::put(&nodes);

            Self::deposit_event(RawEvent::JoinClan(None, node));

            Ok(())
        }
    }
}

impl<T: Config> Module<T> {
    pub fn form_clan(node: PeerId) -> Result<SupraClan, Error<T>> {
        let mut nodes: BTreeSet<PeerId> = BTreeSet::new();
        nodes.insert(node);

        let clan = SupraClan {
            nodes: nodes.clone(),
        };

        Ok(clan)
    }
}


// TODO: Add a form of unique ID for the clan
#[derive(Debug, Clone)]
pub struct SupraClan {
    nodes: BTreeSet<PeerId>,
}
