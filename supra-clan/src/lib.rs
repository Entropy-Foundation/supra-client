#![cfg_attr(not(feature = "std"), no_std)]

/// Edit this file to define custom logic or remove it if it is not needed.
/// Learn more about FRAME and the core library of Substrate FRAME pallets:
/// <https://substrate.dev/docs/en/knowledgebase/runtime/frame>
use frame_support::{
    debug, decl_error, decl_event, decl_module, decl_storage, dispatch::DispatchResult, ensure, traits::{EnsureOrigin, Get}
};

use sp_core::OpaquePeerId as PeerId;
// use uuid::Uuid;

use sp_std::collections::btree_set::BTreeSet;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

pub trait Config: frame_system::Config {
	/// The overarching dispatch call type.
    type Call: From<Call<Self>>;
	/// Because this pallet emits events, it depends on the runtime's definition of an event.
	type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;

    type MaxClanNodes: Get<u32>;
    /// The origin which can add a well known node.
    type CheckOrigin: EnsureOrigin<Self::Origin>;
}

decl_storage! {
	trait Store for Module<T: Config> as SupraClan {
        /// Set of nodes comprising of nodes in a clan
        pub Clan get(fn clan_nodes): BTreeSet<PeerId>;
    }
    add_extra_genesis {
        config(nodes): PeerId;
        build(|config: &GenesisConfig| {
            <Module<T>>::form_clan(config.nodes.clone()).unwrap();
        })
    }
}

decl_event! {
	/// Events generated by the module.
    pub enum Event<T>
    where
        AccountId = <T as frame_system::Config>::AccountId,
    {
        /// Clan is initiated 
        FormClan,
        /// Event submitted when a node joins the clan.
        JoinClan(Option<AccountId>, PeerId),
        /// Event sunmitted when a node leaves the clan
        LeaveClan(u32),
    }
}

decl_error! {
	pub enum Error for Module<T: Config> {
        /// Clan nodes not active
		ClanNotResponsive,
        /// Clan length is exceeded
        TooManyNodes,
        /// Nodes already in Clan
        AlreadyJoined,
        NotInClan,
	}
}

decl_module! {
	pub struct Module<T: Config> for enum Call
        where 	origin: T::Origin,
    {
        fn deposit_event() = default;

        #[weight = 1000]
        pub fn clan_form(origin, node: PeerId) -> DispatchResult {
            T::CheckOrigin::ensure_origin(origin)?;

            Self::form_clan(node).unwrap();

            Self::deposit_event(RawEvent::FormClan);

            Ok(())
        }

        #[weight = 1000]
        pub fn node_join_clan(origin, node: PeerId) -> DispatchResult {
            T::CheckOrigin::ensure_origin(origin)?;

            let mut nodes = Clan::get();
            ensure!(nodes.len() < T::MaxClanNodes::get() as usize, Error::<T>::TooManyNodes);
            ensure!(!nodes.contains(&node), Error::<T>::AlreadyJoined);

            nodes.insert(node.clone());

            Clan::put(&nodes);

            Self::deposit_event(RawEvent::JoinClan(None, node));

            Ok(())
        }

        #[weight = 1000]
        pub fn node_leave_clan(origin, node: PeerId) -> DispatchResult {
            T::CheckOrigin::ensure_origin(origin)?;

            let mut nodes = Clan::get();
            ensure!(nodes.len() < T::MaxClanNodes::get() as usize, Error::<T>::TooManyNodes);
            ensure!(nodes.contains(&node), Error::<T>::NotInClan);

            nodes.remove(&node);

            Clan::put(&nodes);

            Self::deposit_event(RawEvent::JoinClan(None, node));

            Ok(())
        }
	}
}

impl<T: Config> Module<T> {
    pub fn form_clan(node: PeerId) -> Result<SupraClan, Error<T>> {
        let clan_id = 34; // Uuid::new_v4();
        let mut nodes: BTreeSet<PeerId> = BTreeSet::new();
        nodes.insert(node);
        // nodes;

        let clan = SupraClan {
            clan_id,
            nodes: nodes.clone(),
        };

        Ok(clan)
    }	
}

#[derive(Debug, Clone)]
pub struct SupraClan {
    clan_id: u32, // Uuid,
    nodes: BTreeSet<PeerId>,
}

