#![cfg_attr(not(feature = "std"), no_std)]

/// Edit this file to define custom logic or remove it if it is not needed.
/// Learn more about FRAME and the core library of Substrate FRAME pallets:
/// <https://substrate.dev/docs/en/knowledgebase/runtime/frame>
use frame_support::{
    debug, decl_error, decl_event, decl_module, decl_storage, dispatch::DispatchResult, ensure, traits::{EnsureOrigin, Get}
};
use frame_system::{
    ensure_none, ensure_root, ensure_signed
};

use std::collections::VecDeque;
use sp_core::OpaquePeerId as PeerId;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

pub trait Config: frame_system::Config {
	/// The overarching dispatch call type.
    type Call: From<Call<Self>>;
	/// Because this pallet emits events, it depends on the runtime's definition of an event.
	type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;

    type MaxClanNodes: Get<u32>;

    /// The origin which can add a well known node.
    type EnsureOrigin: EnsureOrigin<Self::Origin>;
}

decl_storage! {
	trait Store for Module<T: Config> as SupraClan {
        /// Set of nodes comprising of nodes in a clan
        pub Clan get(fn clan_nodes): VecDeque<PeerId>;
    }
}

decl_event! {
	/// Events generated by the module.
    pub enum Event<T>
    where
        AccountId = <T as frame_system::Config>::AccountId,
    {
        /// Event submitted when a node joins the clan.
        JoinClan(Option<AccountId>, PeerId),
        /// Event sunmitted when a node leaves the clan
        LeaveClan(u32),
    }
}

decl_error! {
	pub enum Error for Module<T: Config> {
        /// Clan nodes not active
		ClanNotResponsive,
        /// Clan length is exceeded
        TooManyNodes,
        /// Nodes already in Clan
        AlreadyJoined,
	}
}

decl_module! {
	pub struct Module<T: Config> for enum Call
        where 	origin: T::Origin,
    {
        fn deposit_event() = default;

        #[weight = 1000]
        pub fn add_node_to_clan(origin, node: PeerId) -> DispatchResult {
            T::EnsureOrigin::ensure_origin(origin)?;

            let mut nodes = Clan::get();
            ensure!(nodes.len() < T::MaxClanNodes::get() as usize, Error::<T>::TooManyNodes);
            ensure!(!nodes.contains(&node), Error::<T>::AlreadyJoined);

            let clan_current_nodes_amount = T::MaxClanNodes::get() as usize;

            nodes.insert(clan_current_nodes_amount, node.clone());

            Clan::put(&nodes);

            Self::deposit_event(RawEvent::JoinClan(None, node));

            Ok(())
        }
	}
}

impl<T: Config> Module<T> {
    pub fn form_clan() -> Result<SupraClan, Error<T>> {
        let clan_id = 1;
        let nodes: VecDeque<PeerId> = VecDeque::new();

        let clan = SupraClan {
            clan_id,
            nodes
        };

        Ok(clan)
    }
	
}

pub struct SupraClan {
    clan_id: u32,
    nodes: VecDeque<PeerId>,
}

